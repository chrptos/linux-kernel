# linux-kernel
試して学ぶLinuxの学習用

# よく使うコマンド

## CPUの使用率を表示
```
sar -P 0 1 1
```

## 特定のCPUでコマンドを実行する
```
taskset -c 0 <command>
```

## システムコールまで何マイクロ秒かかったか調べる
```
// input
strace -T -o <target> <command>

// output: write(1, "Hello, World!\n", 14)         = 14 <0.000158>
```

## forkとexecve
forkはプロセスをコピーするだけなので、コピーされたプロセスで別のプログラムを実行したい場合はexecveが必要

## fork+execveとposix_spawnの用途
forkとexecの間に処理を挟めたい時には、組み合わせれば良くて、それ以外はposix_spawnでもOK
fork+execveはforkの後に親プロセスのファイルディスクリプタを閉じた後に、execveで実行できる
posix_spawnはforkとexecveのオーバーヘッドがないのでより直感的に高速に処理を行える

## プロセスの状態
- プロセス誕生
- プロセス動作中
    - 実行可能状態
    - 実行状態
    - スリープ状態（イベント待ち状態）
- ゾンビ状態
    - プロセス動作中から`exit()`コマンドなどの終了処理が正常に完了した状態
- プロセス終了
    - 親プロセスが終了状態を得た（`wait()`などで）場合に、ゾンビ状態から終了状態に移行する

## exit()とwait()
exit()だけでは子プロセスの終了ステータスを親プロセスに伝えきれず、子プロセスはゾンビプロセスとなってしまうので、
親プロセスはwait()で子プロセスの状態を確認し、子プロセスが終了している（ゾンビ状態である）ことがわかった時に、リソースが回収される。

## 子プロセスより先に親プロセスが終了した時（孤児プロセス）
親プロセスが終了すると子プロセスはpid=1（init）に紐づけられる、pid=1(init)はゾンビ状態の子プロセスを抹消する。
→ initプロセスが定期的にwait()系システムコール実行を発行して、システムのリソースを回収する。

## シグナルはプロセスの状態を変更できる
例えば、Ctrl-zや-cなどが代表例（一時停止ならbgやfgで再開できる）
- 一時停止: SIGSTOP
- 再開処理: SIGCONT
- 強制終了: SIGINT
- 子プロセスの状態が変化した時: SIGCHLD
    - SIGCHLDが送られてきたら、親プロセスは`wait()`系のシステムコールを発行して状態を確認すれば良い。
- その他: `man 7 signal`で確認できる

## プロセスをctrl + zで停止させた場合にkillコマンドで終了させることができない？
> `ctrl + z` キーを使用してプロセスを一時停止させると、そのプロセスは `T`（停止）状態になります。この状態では、プロセスは停止しており、実行されていないため、`kill` コマンドを使用しても終了させることはできません。プロセスを終了させるには、再開する必要があります。
> プロセスを再開するには、`fg` コマンドを使用します。これにより、停止中のプロセスが前景で再開されます。その後、再開されたプロセスを `ctrl + c` キーで終了するか、`kill` コマンドを使用して終了させることができます。
TIPS: プロセスの状態遷移図があるので、見返してみるといいかも？停止状態から終了状態にならないのがわかると思う。

## プロセスのSIGSTOPした時の状態は、状態遷移図のどこに当てはまるのだろう？
一時停止から再開が可能だから「実行可能状態」に含まれそうだけど、どうなんだろう？
第3章で詳しく学べるようなので一旦スキップで

## ジョブとは？
シェルがバックグラウンドで実行したプロセスを管理する仕組み
`jobs`コマンドでバックグラウンドで実行中のジョブを一覧表示できたり、`fg`コマンドでジョブ番号を指定して特定のジョブをフォアグラウンドに移動したりできる。

## セッションとは？
仮想の端末ごとに`pty/[n]`が与えられる。`ps ajx`で確認可能でターミナルのタブを新しく開くとSIDが変わっている。

## ttyとセッション
TODO

## 