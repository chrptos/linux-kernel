# linux-kernel
試して学ぶLinuxの学習用

# よく使うコマンド

## CPUの使用率を表示
```
sar -P 0 1 1
```

## 特定のCPUでコマンドを実行する
```
taskset -c 0 <command>
```

## システムコールまで何マイクロ秒かかったか調べる
```
// input
strace -T -o <target> <command>

// output: write(1, "Hello, World!\n", 14)         = 14 <0.000158>
```

## forkとexecve
forkはプロセスをコピーするだけなので、コピーされたプロセスで別のプログラムを実行したい場合はexecveが必要

## fork+execveとposix_spawnの用途
forkとexecの間に処理を挟めたい時には、組み合わせれば良くて、それ以外はposix_spawnでもOK
fork+execveはforkの後に親プロセスのファイルディスクリプタを閉じた後に、execveで実行できる
posix_spawnはforkとexecveのオーバーヘッドがないのでより直感的に高速に処理を行える

## プロセスの状態
- プロセス誕生
- プロセス動作中
    - 実行可能状態
    - 実行状態
    - スリープ状態（イベント待ち状態）
- ゾンビ状態
    - プロセス動作中から`exit()`コマンドなどの終了処理が正常に完了した状態
- プロセス終了
    - 親プロセスが終了状態を得た（`wait()`などで）場合に、ゾンビ状態から終了状態に移行する

## exit()とwait()
exit()だけでは子プロセスの終了ステータスを親プロセスに伝えきれず、子プロセスはゾンビプロセスとなってしまうので、
親プロセスはwait()で子プロセスの状態を確認し、子プロセスが終了している（ゾンビ状態である）ことがわかった時に、リソースが回収される。

## 子プロセスより先に親プロセスが終了した時（孤児プロセス）
親プロセスが終了すると子プロセスはpid=1（init）に紐づけられる、pid=1(init)はゾンビ状態の子プロセスを抹消する。
→ initプロセスが定期的にwait()系システムコール実行を発行して、システムのリソースを回収する。

## シグナルはプロセスの状態を変更できる
例えば、Ctrl-zや-cなどが代表例（一時停止ならbgやfgで再開できる）
- 一時停止: SIGSTOP
- 再開処理: SIGCONT
- 強制終了: SIGINT
- 子プロセスの状態が変化した時: SIGCHLD
    - SIGCHLDが送られてきたら、親プロセスは`wait()`系のシステムコールを発行して状態を確認すれば良い。
- その他: `man 7 signal`で確認できる

## プロセスをctrl + zで停止させた場合にkillコマンドで終了させることができない？
> `ctrl + z` キーを使用してプロセスを一時停止させると、そのプロセスは `T`（停止）状態になります。この状態では、プロセスは停止しており、実行されていないため、`kill` コマンドを使用しても終了させることはできません。プロセスを終了させるには、再開する必要があります。
> プロセスを再開するには、`fg` コマンドを使用します。これにより、停止中のプロセスが前景で再開されます。その後、再開されたプロセスを `ctrl + c` キーで終了するか、`kill` コマンドを使用して終了させることができます。
TIPS: プロセスの状態遷移図があるので、見返してみるといいかも？停止状態から終了状態にならないのがわかると思う。

## プロセスのSIGSTOPした時の状態は、状態遷移図のどこに当てはまるのだろう？
一時停止から再開が可能だから「実行可能状態」に含まれそうだけど、どうなんだろう？
第3章で詳しく学べるようなので一旦スキップで

## ジョブとは？
シェルがバックグラウンドで実行したプロセスを管理する仕組み
`jobs`コマンドでバックグラウンドで実行中のジョブを一覧表示できたり、`fg`コマンドでジョブ番号を指定して特定のジョブをフォアグラウンドに移動したりできる。

## セッションとは？
仮想の端末ごとに`pty/[n]`が与えられる。`ps ajx`で確認可能でターミナルのタブを新しく開くとSIDが変わっている。

## 全体像
- カーネル空間（カーネルモード）
    - カーネル空間は、オペレーティングシステムのカーネル（OSの核心部分）が実行されるメモリ空間です。
    - カーネルは、ハードウェアリソースへの直接的なアクセスと、低レベルのシステムタスク（プロセス管理、メモリ管理、デバイスドライバの実行など）を担います。
    - カーネルモードでは、CPUは全ての命令を実行できる最高レベルの権限を持ちます。
- ユーザ空間
    - ユーザ空間は、ユーザーのアプリケーションやプログラムが実行されるメモリ空間です。
    - ここで実行されるプロセスは、カーネル空間に比べて限定された権限を持ち、ハードウェアリソースへの直接的なアクセスは許可されていません。
    - ユーザーモードで動作するプログラムは、システムリソースを安全に利用するために、カーネルに仲介してもらう必要があります。
- システムコール
    - システムコールは、ユーザ空間のプログラムがカーネル空間の機能を利用するためのインターフェースです。
    - プログラムがファイル操作、ネットワーク通信、プロセス制御などのシステムリソースにアクセスする必要がある場合、システムコールを介してカーネルにリクエストを送ります。
    - カーネルは、システムコールを受け取り、要求された操作を安全に実行した後、結果をユーザ空間のプログラムに返します。
- ユーザ空間
    - プロセス
        - スレッド
            - スレッドはプロセス内で実行される軽量な実行単位であり、その実行にはCPUの実行コンテキスト（プログラムカウンタ、レジスタセットなど）とスタックが必要です。しかし、コード、データセグメント、およびヒープなどのメモリ領域はプロセス内のすべてのスレッドで共有されます。
            - この共有された仮想アドレス空間を使用することで、スレッドは以下のような特性を実現します
                - 高速なコンテキストスイッチ：スレッド間で大部分のメモリ空間が共有されているため、スレッド間のコンテキストスイッチはプロセス間のスイッチに比べてオーバーヘッドが少なく、高速です。
                - 共有データへのアクセス：共有メモリ空間により、スレッド間でのデータ共有が容易になります。これにより、高度に並列な計算や効率的なデータ処理が可能になりますが、同期のための機構（ミューテックス、セマフォなど）が必要になる場合があります。
        - 仮想アドレス空間
            - 安全性の向上: コンピュータシステムの普及と共に、複数のプログラムが同時に実行されるようになりました。これに伴い、プロセス間のメモリ領域を適切に隔離し、不正アクセスや衝突を防ぐ必要が生じました。
            - 効率的なリソース利用: 物理メモリの容量は限られており、特に初期のコンピュータシステムではその制約が顕著でした。仮想メモリ技術を用いることで、限られた物理リソースをより効率的に活用することが求められました。
            - プログラムの開発と保守の容易さ: プログラムが特定の物理アドレスに依存することなく開発できるようにすることで、プログラムの開発、デバッグ、保守が容易になりました。
    - 仮想マシン
        - 仮想マシン（VM）は、カーネル空間の準仮想化や仮想化機能、およびハードウェアの仮想化支援機能を利用して実現されています。これらの技術は、物理ハードウェアリソースを複数の仮想マシン間で効率的に共有し、それぞれのVMが独立したコンピュータシステムであるかのように動作することを可能にします。
            - カーネル空間の準仮想化：準仮想化は、ゲストオペレーティングシステム（OS）が仮想化環境に最適化された形で動作するように、一部の修正を加える仮想化手法です。この方法では、ゲストOSが直接ハードウェアにアクセスする代わりに、仮想化レイヤーを通じてリソースへのアクセスを行います。これにより、パフォーマンスのオーバーヘッドを最小限に抑えつつ、安全な仮想化環境を実現します。
            - ハードウェアの仮想化支援機能:近年のCPUには、Intel VT-xやAMD-Vのようなハードウェアの仮想化支援機能が搭載されています。これらの技術は、仮想マシンモニタ（VMM）またはハイパーバイザと呼ばれるソフトウェアが、物理リソースを効率的に管理し、各仮想マシンにリソースを分配するのを助けます。ハードウェアの仮想化支援機能により、フルバーチャライゼーション（完全仮想化）が可能になり、ゲストOSを修正することなく、様々なOSをそのままの形で実行できます。
            - 実現される仮想マシンの種類
                - フルバーチャライゼーション: フルバーチャライゼーションでは、ハイパーバイザーが物理ハードウェアを完全にエミュレートします。これにより、ゲストオペレーティングシステムは仮想化された環境が物理ハードウェアであると認識し、修正なしでそのまま実行できます。しかし、このアプローチではエミュレーションによるオーバーヘッドが発生し、パフォーマンスが低下する可能性があります。
                - 準仮想化: ゲストオペレーティングシステムがハイパーバイザーAPIを直接呼び出すことで、ハードウェアの一部機能をエミュレートします。これにより、物理ハードウェアの完全なエミュレーションを避けることができ、パフォーマンスの向上が期待できます。ただし、ゲストOSは仮想化環境用に特別に修正される必要があります。
    - コンテナ
        - ユーザ空間の隔離: コンテナは、オペレーティングシステムのカーネルを共有しながらも、ユーザ空間（アプリケーションとその実行環境）を隔離します。これは、Linuxの名前空間（namespaces）と制御グループ（cgroups）などの機能を使用して実現されます。各コンテナは独自のファイルシステム、プロセスID空間、ネットワークインターフェースなどを持ち、他のコンテナやホストシステムから隔離されます。
        - 軽量な仮想化: 伝統的な仮想マシンと比較して、コンテナはOSレベルでの仮想化を提供します。これにより、ハードウェアをエミュレートする必要がなく、起動時間が短縮され、リソース使用効率が向上します。コンテナは必要なライブラリやアプリケーションの実行バイナリのみを含むため、ディスク使用量も少なくなります。
        - 環境の一貫性: コンテナは、開発、テスト、本番環境間での環境の一貫性を提供します。アプリケーションは、異なる環境間で移動しても同じユーザ空間（同じ依存関係と設定）で実行されるため、"動作しない"という問題を大幅に減少させます。
- カーネル空間
    - ファイルシステム
        - インターフェースの提供: カーネルは、アプリケーションがファイルシステムにアクセスするためのインターフェース（システムコール）を提供します。アプリケーションは、ファイルの読み書き、ディレクトリの操作などを行うために、これらのシステムコールを使用します。
        - ファイルシステムの実装: カーネル空間内でファイルシステムが実装されます。これにより、カーネルは直接ファイルシステムの操作を行い、ファイルへのアクセスや管理を効率的に行うことができます。
        - 抽象化レイヤーの提供: カーネルは、ファイルシステムの抽象化レイヤーを提供し、異なる種類のファイルシステム（例: ext4、NTFS、FAT32）に対して一貫したアクセス方法を提供します。
        - バッファリングとキャッシング: カーネルは、ファイルシステムのパフォーマンスを向上させるために、データのバッファリングとキャッシングを行います。これにより、ディスクI/Oの回数が減少し、アクセス速度が向上します。
    - プロセス管理
        - プロセス管理は、プロセスの作成、実行、終了など、プロセスのライフサイクル全般を管理する機能を指します。これには以下のようなタスクが含まれます。
            - プロセスの作成
                - フォーク(fork)とエグゼク(exec): Unix系オペレーティングシステムでは、新しいプロセスは通常、既存のプロセスがfork()システムコールを使用して自身のコピーを作成することにより作成されます。作成された子プロセスは、exec()システムコールを使って新しいプログラムをロードして実行します。
                - プロセス識別子(PID): カーネルは、各プロセスに一意のプロセス識別子（PID）を割り当てます。これにより、プロセスを識別し、管理することができます。
            - プロセスの終了
                - 終了ステータス: プロセスが終了する際、カーネルはその終了ステータスを保持します。親プロセスは、wait()システムコールを使用して子プロセスの終了ステータスを取得できます。
                - リソースの解放: プロセスが終了すると、カーネルはそのプロセスが使用していたリソース（メモリ、オープンしていたファイルのハンドル、ネットワーク接続など）を解放します。
            - プロセスの階層（親子関係）の管理
            - プロセスへのリソースの割り当てと解放
    - プロセススケジューラ
        - プロセススケジューラは、システム上で実行される複数のプロセスやスレッド間でCPU時間をどのように割り当てるかを決定するカーネルのコンポーネントです。スケジューラは以下のような責務を持ちます。
            - CPU時間の割り当て: 実行待ちのプロセスの中から、どのプロセスを次に実行するかを選択し、CPU時間を割り当てます。
            - フェアなスケジューリング: すべてのプロセスが公平にCPU時間を受け取るようにスケジュールします。これには、プロセスの優先度、プロセスの種類（フォアグラウンド、バックグラウンド）、プロセスの実行時間などが考慮されます。
            - システムの応答性とスループットの最適化: ユーザーインターフェースの応答性を高めたり、バックグラウンドで実行されるプロセスのスループットを最適化したりします。
            - コンテキストスイッチの管理: 現在実行中のプロセスから別のプロセスへCPUの制御を移行する際に、必要な情報（コンテキスト）を保存・復元します。
    - プロセス管理とプロセススケジューラの関係性
        - プロセス管理とプロセススケジューラは、オペレーティングシステムのカーネルにおける密接に関連する二つの重要な機能です。これらは、システム上で複数のプロセスが効率的に、かつ公平に実行されることを保証するために連携して動作します。
        - プロセス管理
            - プロセス管理は、プロセスのライフサイクル全体を扱うカーネルの機能です。これには、プロセスの作成（フォーク）、実行（スケジューリング）、終了（終了ステータスの管理とリソースの解放）などが含まれます。プロセス管理は、システム上で実行される各プロセスが必要なリソース（CPU時間、メモリ、I/Oデバイスなど）を適切に利用できるようにする責任を持ちます。
        - プロセススケジューラ
            - プロセススケジューラは、カーネル内のプロセス管理システムの一部であり、実行可能なプロセスの中からどのプロセスを次にCPUに割り当てるかを決定する役割を持ちます。プロセススケジューラは、プロセスの優先度、プロセスの種類（フォアグラウンドプロセスやバックグラウンドプロセス）、プロセスの実行時間など、さまざまな要因を考慮して、最も適切なプロセスを選択します。
        - 両者の関係
            - 連携動作: プロセス管理はプロセスの作成と終了を扱い、プロセススケジューラはこれらのプロセスの実行順序を管理します。プロセスがシステム上で実行されるためには、プロセス管理によって適切に初期化され、プロセススケジューラによってCPU時間が割り当てられる必要があります。
            - 効率的なリソース利用: プロセス管理とプロセススケジューラは、システムリソースを最も効率的に利用し、システムの応答性とスループットを最適化するために連携します。
            - プロセス間の公平性: プロセススケジューラは、すべてのプロセスが公平にリソースを利用できるようにするために、プロセス管理システムと緊密に連携します。これにより、一部のプロセスが他のプロセスを圧迫することなく、バランスの取れた実行が可能になります。
        - 総括
            - 総じて、プロセス管理とプロセススケジューラは、オペレーティングシステムのカーネルにおけるプロセスの効率的な実行と管理を可能にするために相互に依存し合っています。これらの機能により、マルチタスク環境が実現され、複数のアプリケーションが同時に実行される現代のコンピュータシステムの要求を満たしています。

    - プロセス間通信（IPC）
        - メカニズム: カーネルは、プロセス間通信（IPC）のための複数のメカニズム（パイプ、共有メモリ、セマフォ、メッセージキューなど）を提供します。これにより、プロセスはデータを交換したり、相互に同期を取ったりすることができます。
    
    - プロセススケジューラ
    - メモリ管理
    - 準仮想化
    - namespaceとcgroup
